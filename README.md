Over the summer before my Junior year, I spent the majority of my time working with a PIC16f690 Microcontroller which came with Microchip inc.'s PICkit2 development kit. I began by working with a BASIC Stamp controller from Parallax inc., getting to know what a microcontroller actually does and learning some of the basics. I toyed with that for about a week, then I moved onto the PICkit2.  The kit included a disc with the MPLAB development environment and a PICkit2 programming device which, when plugged up to the board and plugged up to my computer, allowed me to download my programs into the PIC. The development board came loaded with four red LEDs, a potentiometer and a button. I began by getting my hands on a book entitled The Quintessential PIC Microcontroller, by Sid Katzen, which walked me through the steps of learning the inner hardware of a PIC (through looking at a PIC16f84) and teaching me the assembly language.

 After I learned some basic PIC programming I began implementing some simple programs. First I played around with the LEDs on the development board (you can see the assembly code above), making them turn on and off in different patterns and simply getting to know the PIC and the development environment. I continued to move through the book and as I did I attempted to play with some motors. I  acquired some parallax pulse width modulation (PWM) motors, and hooked them up to a bread board which I bought at Radio Shack. I worked through getting the motors to move with PIC Assembly, where my major issue was trying to get the math of the timing down. Although the book I was using provided some examples of timing code (code which paused the PIC for a certain amount of time), trying to get the timing I wanted was, for lack of a better word, frustrating.

Eventually I got the motors to run at varying speeds and in return had produced some nice timing code I could use elsewhere. I then moved on to integrating a bump switch (I scavenged one from a VEX robotics kit my little brother Paul had but never used). I set up the switch with the PIC so that it would pull down an input pin (which was pulled to logic 1) whenever it was pressed, causing the controller to "turn" right by alternating two motors (see code above). I then moved onto a Parallax Sonic Range Finder, which was troublesome to say the least. The range finder would wait for a staring signal from the microcontroller, at which point it would wait a few cycles, send out an ultrasonic pulse. The range finder would then pull the pin connected to the controller up, and it would remain up until the pulse was detected again or until a certain amount of time had passed. I set up my PIC so that it used its internal binary counter (TMR0, which incremented with every cycle) to determine the amount of time the pin remained up. If the counter's register overflowed then an interrupt was triggered which incremented a seperate counter which kept track of overflows. After the range finder's pin went down, then the PIC would display the result on the development board's LEDs.

I tested with a large flat book I placed directly in line with the range finder, exactly 30cm away. No matter what I did the PIC would always return the wrong value. I changed everything in my code, from the timing code to the display code, I was sure that there was something that I was implementing incorrectly which was causing my faulty readings. That was where it ended, the school year began I was dragged back into the time black hole that is AP classes and Speech and Debate. Looking back at my code and my problems, I assume that some of my math regarding the speed of the sonic waves threw off my PIC's calculations. I learned more than I could have possibly imagined. I wouldn't trade my PIC experience for any other summer activity.